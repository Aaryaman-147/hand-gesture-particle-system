<!--
 * Gesture Controlled 3D Particle System
 * ------------------------------------
 * Tech: Three.js + MediaPipe Hands
 * Interaction: Real-time hand gesture tracking
 * Author: Aaryaman Arora
 * Demo: <live link if you deploy>
-->

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gesture Controlled 3D Particles</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #050505;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            color: white;
        }
        #canvas-container {
            width: 100vw;
            height: 100vh;
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
        }
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 20px;
            box-sizing: border-box;
        }
        .hud-panel {
            background: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(5px);
            padding: 15px;
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            pointer-events: auto;
            max-width: 300px;
        }
        h1 {
            margin: 0 0 10px 0;
            font-size: 1.2rem;
            color: #4facfe;
            text-transform: uppercase;
            letter-spacing: 2px;
        }
        p {
            margin: 5px 0;
            font-size: 0.9rem;
            color: #ccc;
        }
        .status-dot {
            height: 10px;
            width: 10px;
            background-color: #ff4444;
            border-radius: 50%;
            display: inline-block;
            margin-right: 8px;
        }
        .status-dot.active {
            background-color: #00ff88;
            box-shadow: 0 0 10px #00ff88;
        }
        #video-preview {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 160px;
            height: 120px;
            border-radius: 10px;
            transform: scaleX(-1); /* Mirror */
            border: 2px solid rgba(255, 255, 255, 0.2);
            background: #000;
            object-fit: cover;
            z-index: 20;
            opacity: 0;
            transition: opacity 0.5s;
        }
        #video-preview.visible {
            opacity: 0.8;
        }
        button {
            background: linear-gradient(90deg, #4facfe 0%, #00f2fe 100%);
            border: none;
            border-radius: 25px;
            padding: 10px 25px;
            color: #000;
            font-weight: bold;
            cursor: pointer;
            margin-top: 10px;
            transition: transform 0.2s, box-shadow 0.2s;
            pointer-events: auto;
        }
        button:hover {
            transform: scale(1.05);
            box-shadow: 0 0 15px rgba(79, 172, 254, 0.5);
        }
        button:disabled {
            background: #444;
            color: #888;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }
        .gesture-guide {
            margin-top: 15px;
            font-size: 0.8rem;
        }
        .gesture-item {
            display: flex;
            align-items: center;
            margin-bottom: 5px;
        }
        .gesture-icon {
            width: 20px;
            text-align: center;
            margin-right: 10px;
            font-weight: bold;
            color: #4facfe;
        }
        #loading {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.8);
            color: white;
            padding: 20px;
            border-radius: 10px;
            display: none;
            z-index: 100;
        }
    </style>
    <!-- Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- MediaPipe Hands -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils@0.6/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils@0.3/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1675469240/hands.js" crossorigin="anonymous"></script>
</head>
<body>

<div id="loading">Initializing Computer Vision...</div>

<div id="ui-layer">
    <div class="hud-panel">
        <h1>Particle Core</h1>
        <div><span id="status-dot" class="status-dot"></span><span id="status-text">System Standby</span></div>
        <p>Current Shape: <strong id="shape-name" style="color: #4facfe">Sphere</strong></p>
        <p>Expansion: <span id="expansion-val">1.0</span>x</p>
        
        <button id="start-btn">Start Camera Control</button>

        <div class="gesture-guide">
            <div class="gesture-item"><span class="gesture-icon">üëè</span> Hands Together: Explosion</div>
            <div class="gesture-item"><span class="gesture-icon">ü§ò</span> Rock On: Star Map</div>
            <div class="gesture-item"><span class="gesture-icon">ü§ô</span> Shaka: Cyber Iris</div>
            <div class="gesture-item"><span class="gesture-icon">‚úä</span> Fist: Galactic Vortex</div>
            <div class="gesture-item"><span class="gesture-icon">‚òùÔ∏è</span> 1 Finger: Saturn</div>
            <div class="gesture-item"><span class="gesture-icon">‚úåÔ∏è</span> 2 Fingers: Heart</div>
            <div class="gesture-item"><span class="gesture-icon">ü§ü</span> 3 Fingers: Flower</div>
            <div class="gesture-item"><span class="gesture-icon">üññ</span> 4 Fingers: DNA Helix</div>
            <div class="gesture-item"><span class="gesture-icon">üñê</span> 5 Fingers: Sphere</div>
            <div class="gesture-item"><span class="gesture-icon">ü§è</span> Pinch: Scale Size</div>
        </div>
    </div>
</div>

<video id="video-preview" playsinline autoplay muted></video>
<div id="canvas-container"></div>

<script>
/**
 * 3D Particle System with Gesture Control
 * Uses Three.js for rendering and MediaPipe Hands for tracking.
 */

// --- Configuration ---
const PARTICLE_COUNT = 15000;
const PARTICLE_SIZE = 0.07;
const COLORS = {
    sphere: [0.2, 0.6, 1.0], // Blue-ish
    heart: [1.0, 0.2, 0.4],  // Red/Pink
    flower: [0.8, 0.3, 0.9], // Purple
    saturn: [0.9, 0.7, 0.2], // Gold
    helix: [0.0, 1.0, 0.5],  // Cyan/Green
    vortex: [0.5, 0.1, 0.8], // Deep Purple
    explosion: [1.0, 0.6, 0.0], // Orange/Gold Fire
    iris: [0.3, 1.0, 1.0],   // Cyan/Bright Blue
    constellation: [0.9, 0.9, 1.0] // White/Silver
};

// --- Global State ---
let scene, camera, renderer, particles, geometry, material;
let targetPositions = new Float32Array(PARTICLE_COUNT * 3);
let currentPositions = new Float32Array(PARTICLE_COUNT * 3);
let currentColors = new Float32Array(PARTICLE_COUNT * 3);
let targetColors = new Float32Array(PARTICLE_COUNT * 3);
let expansion = 1.0;
let rotationSpeed = { x: 0, y: 0.001 };
let targetRotation = { x: 0, y: 0 };
let currentShape = 'sphere';
let isTracking = false;
let lastHandTime = 0; // Timestamp of last hand detection

// --- Three.js Setup ---
function initThree() {
    const container = document.getElementById('canvas-container');

    scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x000000, 0.02);

    camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.z = 9;

    renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    container.appendChild(renderer.domElement);

    // Create Particles
    geometry = new THREE.BufferGeometry();
    const positions = [];
    const colors = [];

    const color = new THREE.Color();
    color.setRGB(COLORS.sphere[0], COLORS.sphere[1], COLORS.sphere[2]);

    for (let i = 0; i < PARTICLE_COUNT; i++) {
        positions.push((Math.random() - 0.5) * 10, (Math.random() - 0.5) * 10, (Math.random() - 0.5) * 10);
        colors.push(color.r, color.g, color.b);
        
        // Init target arrays
        targetColors[i*3] = color.r;
        targetColors[i*3+1] = color.g;
        targetColors[i*3+2] = color.b;
    }

    geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
    geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));

    // Copy initial to arrays
    currentPositions.set(positions);
    currentColors.set(colors);

    // Material
    const sprite = new THREE.TextureLoader().load('https://threejs.org/examples/textures/sprites/disc.png');
    material = new THREE.PointsMaterial({
        size: PARTICLE_SIZE,
        map: sprite,
        vertexColors: true,
        blending: THREE.AdditiveBlending,
        depthTest: false,
        transparent: true,
        opacity: 0.8
    });

    particles = new THREE.Points(geometry, material);
    scene.add(particles);

    // Initial shape
    calculateShape('sphere');

    window.addEventListener('resize', onWindowResize, false);
    animate();
}

function onWindowResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
}

// --- Shape Math ---
function calculateShape(shape) {
    if (shape === currentShape) return; 
    currentShape = shape;
    
    // Nice Title Formatting
    const titles = {
        'vortex': 'Galactic Vortex',
        'saturn': 'Saturn Ring',
        'heart': 'Neon Heart',
        'flower': 'Cyber Flower',
        'helix': 'DNA Helix',
        'sphere': 'Particle Sphere',
        'explosion': 'SUPERNOVA',
        'iris': 'Cyber Iris',
        'constellation': 'Star Map'
    };
    const title = titles[shape] || 'Unknown';
    document.getElementById('shape-name').innerText = title;

    const positions = targetPositions; // Write to global target array
    let colorSet = COLORS[shape] || COLORS.sphere;

    // Helper: Set global target colors uniformly
    for(let i=0; i<PARTICLE_COUNT; i++) {
        // Add variation to color for richness
        let variation = (Math.random() - 0.5) * 0.2;
        
        // Special color logic
        if (shape === 'explosion') {
            const r = 1.0;
            const g = Math.random() * 0.8; 
            const b = Math.random() * 0.2;
            targetColors[i*3] = r;
            targetColors[i*3+1] = g;
            targetColors[i*3+2] = b;
        } 
        else if (shape === 'iris') {
            // Dark pupil for the first 10%
            if (i < PARTICLE_COUNT * 0.1) {
                targetColors[i*3] = 0.05; // Almost black
                targetColors[i*3+1] = 0.05;
                targetColors[i*3+2] = 0.05;
            } else {
                targetColors[i*3] = Math.max(0, Math.min(1, colorSet[0] + variation));
                targetColors[i*3+1] = Math.max(0, Math.min(1, colorSet[1] + variation));
                targetColors[i*3+2] = Math.max(0, Math.min(1, colorSet[2] + variation));
            }
        }
        else if (shape === 'constellation') {
             // Twinkling stars effect (white/blue-ish)
             const brightness = 0.5 + Math.random() * 0.5;
             targetColors[i*3] = colorSet[0] * brightness;
             targetColors[i*3+1] = colorSet[1] * brightness;
             targetColors[i*3+2] = colorSet[2] * brightness;
        }
        else {
            targetColors[i*3] = Math.max(0, Math.min(1, colorSet[0] + variation));
            targetColors[i*3+1] = Math.max(0, Math.min(1, colorSet[1] + variation));
            targetColors[i*3+2] = Math.max(0, Math.min(1, colorSet[2] + variation));
        }
    }

    if (shape === 'sphere') {
        const radius = 3.5;
        for (let i = 0; i < PARTICLE_COUNT; i++) {
            const phi = Math.acos(-1 + (2 * i) / PARTICLE_COUNT);
            const theta = Math.sqrt(PARTICLE_COUNT * Math.PI) * phi;
            positions[i * 3] = radius * Math.cos(theta) * Math.sin(phi);
            positions[i * 3 + 1] = radius * Math.sin(theta) * Math.sin(phi);
            positions[i * 3 + 2] = radius * Math.cos(phi);
        }
    } 
    else if (shape === 'heart') {
        const scale = 0.25;
        for (let i = 0; i < PARTICLE_COUNT; i++) {
            const theta = Math.random() * Math.PI * 2;
            const hx = 16 * Math.pow(Math.sin(theta), 3);
            const hy = 13 * Math.cos(theta) - 5 * Math.cos(2*theta) - 2 * Math.cos(3*theta) - Math.cos(4*theta);
            const hz = (Math.random() - 0.5) * 6; // Thickness

            positions[i*3] = hx * scale;
            positions[i*3+1] = hy * scale;
            positions[i*3+2] = hz * (1 - Math.abs(hy)/25); 
        }
    }
    else if (shape === 'flower') {
        for(let i=0; i<PARTICLE_COUNT; i++) {
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.random() * Math.PI;
            
            const k = 5; 
            const rBase = 2 + Math.cos(k * theta) * Math.sin(phi) * 2;
            
            const isInner = i > PARTICLE_COUNT * 0.7;
            const r = isInner ? rBase * 0.5 : rBase;
            const yOffset = isInner ? 0.5 : 0;

            positions[i*3] = r * Math.cos(theta) * Math.sin(phi);
            positions[i*3+1] = r * Math.sin(theta) * Math.sin(phi);
            positions[i*3+2] = (r * Math.cos(phi)) * 0.5 + yOffset; 
        }
    }
    else if (shape === 'saturn') {
        const planetRatio = 0.3;
        const planetCount = Math.floor(PARTICLE_COUNT * planetRatio);
        const radius = 1.2;
        
        // Planet
        for (let i = 0; i < planetCount; i++) {
            const phi = Math.acos(-1 + (2 * i) / planetCount);
            const theta = Math.sqrt(planetCount * Math.PI) * phi;
            positions[i * 3] = radius * Math.cos(theta) * Math.sin(phi);
            positions[i * 3 + 1] = radius * Math.sin(theta) * Math.sin(phi);
            positions[i * 3 + 2] = radius * Math.cos(phi);
        }
        
        // Rings
        for (let i = planetCount; i < PARTICLE_COUNT; i++) {
            const angle = Math.random() * Math.PI * 2;
            const dist = 2.0 + Math.random() * 2.5; 
            
            positions[i * 3] = Math.cos(angle) * dist;
            positions[i * 3 + 1] = (Math.random() - 0.5) * 0.1; // Very thin
            positions[i * 3 + 2] = Math.sin(angle) * dist;
        }
    }
    else if (shape === 'helix') {
        // Double Helix
        for (let i = 0; i < PARTICLE_COUNT; i++) {
            const isStrandA = i % 2 === 0;
            const t = (i / PARTICLE_COUNT) * Math.PI * 10; 
            const y = (i / PARTICLE_COUNT) * 8 - 4; 
            const radius = 1.5;
            
            const angleOffset = isStrandA ? 0 : Math.PI;
            
            let x = radius * Math.cos(t + angleOffset);
            let z = radius * Math.sin(t + angleOffset);
            
            x += (Math.random() - 0.5) * 0.5;
            z += (Math.random() - 0.5) * 0.5;
            
            positions[i * 3] = x;
            positions[i * 3 + 1] = y;
            positions[i * 3 + 2] = z;
        }
    }
    else if (shape === 'vortex') {
        for (let i = 0; i < PARTICLE_COUNT; i++) {
            const armCount = 3;
            const armIndex = i % armCount;
            const t = Math.random() * 10;
            
            const offset = (Math.PI * 2 / armCount) * armIndex;
            const angle = t + offset;
            
            const r = t * 0.5; 
            
            let x = r * Math.cos(angle);
            let z = r * Math.sin(angle);
            let y = (Math.random() - 0.5) * (4 / (r + 0.1));
            
            if (i < 2000) {
                x = (Math.random() - 0.5) * 1.5;
                y = (Math.random() - 0.5) * 1.5;
                z = (Math.random() - 0.5) * 1.5;
            }

            positions[i * 3] = x;
            positions[i * 3 + 1] = y;
            positions[i * 3 + 2] = z;
        }
    }
    else if (shape === 'explosion') {
        for (let i = 0; i < PARTICLE_COUNT; i++) {
            const r = 5 + Math.random() * 15;
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.random() * Math.PI;
            
            positions[i * 3] = r * Math.cos(theta) * Math.sin(phi);
            positions[i * 3 + 1] = r * Math.sin(theta) * Math.sin(phi);
            positions[i * 3 + 2] = r * Math.cos(phi);
        }
    }
    else if (shape === 'iris') {
        for (let i = 0; i < PARTICLE_COUNT; i++) {
            // Pupil
            if (i < PARTICLE_COUNT * 0.1) {
                 const r = Math.pow(Math.random(), 0.5) * 0.8;
                 const theta = Math.random() * Math.PI * 2;
                 positions[i * 3] = r * Math.cos(theta);
                 positions[i * 3 + 1] = r * Math.sin(theta);
                 positions[i * 3 + 2] = (Math.random() - 0.5) * 0.1;
            } else {
                 // Iris
                 const r = 0.8 + Math.pow(Math.random(), 0.8) * 2.2; 
                 const theta = Math.random() * Math.PI * 2;
                 const z = Math.sqrt(4*4 - r*r) * -0.25; 
                 positions[i * 3] = r * Math.cos(theta);
                 positions[i * 3 + 1] = r * Math.sin(theta);
                 positions[i * 3 + 2] = z + (Math.random()-0.5)*0.15;
            }
        }
    }
    else if (shape === 'constellation') {
        // Celestial Sphere + Milky Way Band
        for (let i = 0; i < PARTICLE_COUNT; i++) {
            // 60% of stars in a dense band (Milky Way)
            if (i < PARTICLE_COUNT * 0.6) {
                const angle = Math.random() * Math.PI * 2;
                const r = 3.5 + (Math.random() - 0.5) * 1.0;
                
                // Band logic: x/y plane, tilted
                // Base pos
                let x = r * Math.cos(angle);
                let z = r * Math.sin(angle);
                let y = (Math.random() - 0.5) * 1.5; // Band width
                
                // Tilt 45 degrees
                const tilt = 0.7; // radians
                let yFinal = y * Math.cos(tilt) - z * Math.sin(tilt);
                let zFinal = y * Math.sin(tilt) + z * Math.cos(tilt);
                
                positions[i * 3] = x;
                positions[i * 3 + 1] = yFinal;
                positions[i * 3 + 2] = zFinal;
            } else {
                // 40% scattered uniformly on outer sphere
                const radius = 4.0;
                const phi = Math.acos(-1 + (2 * (i - PARTICLE_COUNT*0.6)) / (PARTICLE_COUNT*0.4));
                const theta = Math.sqrt((PARTICLE_COUNT*0.4) * Math.PI) * phi;
                
                positions[i * 3] = radius * Math.cos(theta) * Math.sin(phi);
                positions[i * 3 + 1] = radius * Math.sin(theta) * Math.sin(phi);
                positions[i * 3 + 2] = radius * Math.cos(phi);
            }
        }
    }
}

// --- Animation Loop ---
function animate() {
    requestAnimationFrame(animate);

    const positions = geometry.attributes.position.array;
    const colors = geometry.attributes.color.array;
    const lerpSpeed = 0.05;
    const now = Date.now();

    // --- IDLE / ACTIVE LOGIC ---
    // If tracking is active but no hand seen for 1000ms, assume idle
    const isHandLost = isTracking && (now - lastHandTime > 1000);

    if (isHandLost) {
        // -- IDLE MODE --
        if (currentShape !== 'sphere') calculateShape('sphere');
        
        document.getElementById('shape-name').innerText = "Scanning...";
        
        const breath = 1.0 + Math.sin(now * 0.002) * 0.2;
        expansion += (breath - expansion) * 0.05; 
        
        particles.rotation.y += 0.002;
        particles.rotation.x += (0 - particles.rotation.x) * 0.05; 

    } else if (!isTracking) {
        // -- PRE-START MODE --
        particles.rotation.y += 0.002;
    } else {
        // -- ACTIVE HAND MODE --
        let autoRotY = 0;
        if (currentShape === 'vortex') autoRotY = 0.01;
        if (currentShape === 'helix') autoRotY = 0.005;
        if (currentShape === 'constellation') autoRotY = 0.0005; // Slow rotation for stars

        // Apply hand rotation with smoothing
        particles.rotation.x += (targetRotation.x - particles.rotation.x) * 0.05;
        particles.rotation.y += (targetRotation.y - particles.rotation.y) * 0.05 + autoRotY;
    }

    // --- PARTICLE PHYSICS LOOP ---
    for (let i = 0; i < PARTICLE_COUNT; i++) {
        const tx = targetPositions[i * 3] * expansion;
        const ty = targetPositions[i * 3 + 1] * expansion;
        const tz = targetPositions[i * 3 + 2] * expansion;

        currentPositions[i * 3] += (tx - currentPositions[i * 3]) * lerpSpeed;
        currentPositions[i * 3 + 1] += (ty - currentPositions[i * 3 + 1]) * lerpSpeed;
        currentPositions[i * 3 + 2] += (tz - currentPositions[i * 3 + 2]) * lerpSpeed;
        
        // Jitter
        const noise = 0.02;
        positions[i * 3] = currentPositions[i * 3] + (Math.random()-0.5)*noise;
        positions[i * 3 + 1] = currentPositions[i * 3 + 1] + (Math.random()-0.5)*noise;
        positions[i * 3 + 2] = currentPositions[i * 3 + 2] + (Math.random()-0.5)*noise;

        // Color
        currentColors[i*3] += (targetColors[i*3] - currentColors[i*3]) * 0.03;
        currentColors[i*3+1] += (targetColors[i*3+1] - currentColors[i*3+1]) * 0.03;
        currentColors[i*3+2] += (targetColors[i*3+2] - currentColors[i*3+2]) * 0.03;
        
        colors[i*3] = currentColors[i*3];
        colors[i*3+1] = currentColors[i*3+1];
        colors[i*3+2] = currentColors[i*3+2];
    }

    geometry.attributes.position.needsUpdate = true;
    geometry.attributes.color.needsUpdate = true;
    renderer.render(scene, camera);
}


// --- MediaPipe Hands Logic ---
const videoElement = document.getElementById('video-preview');
const startBtn = document.getElementById('start-btn');
const statusDot = document.getElementById('status-dot');
const statusText = document.getElementById('status-text');
const loading = document.getElementById('loading');

startBtn.addEventListener('click', async () => {
    startBtn.disabled = true;
    statusText.innerText = "Initializing Camera...";
    loading.style.display = 'block';
    
    const hands = new Hands({locateFile: (file) => {
        return `https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1675469240/${file}`;
    }});

    hands.setOptions({
        maxNumHands: 2, 
        modelComplexity: 1,
        minDetectionConfidence: 0.6,
        minTrackingConfidence: 0.6
    });

    hands.onResults(onResults);

    const detectHand = async () => {
        if (!isTracking) return;
        if (videoElement.readyState >= 2 && videoElement.videoWidth > 0) { 
            await hands.send({image: videoElement});
        }
        requestAnimationFrame(detectHand);
    };

    try {
        let stream;
        try {
            stream = await navigator.mediaDevices.getUserMedia({
                video: { width: { ideal: 320 }, height: { ideal: 240 }, facingMode: "user" }
            });
        } catch (err) {
            console.warn("Preferred camera settings failed, using default.", err);
            stream = await navigator.mediaDevices.getUserMedia({ video: true });
        }

        videoElement.srcObject = stream;
        
        await new Promise((resolve, reject) => {
            videoElement.onloadedmetadata = () => {
                videoElement.play().then(resolve).catch(reject);
            };
            videoElement.onerror = reject;
        });

        videoElement.classList.add('visible');
        statusDot.classList.add('active');
        statusText.innerText = "Tracking Active";
        loading.style.display = 'none';
        isTracking = true;
        detectHand();
        
    } catch (e) {
        console.error(e);
        statusText.innerText = "Error: Camera unavailable";
        loading.style.display = 'none';
        startBtn.disabled = false;
        alert("Camera failed to start. " + e.message);
    }
});

function onResults(results) {
    if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
        lastHandTime = Date.now(); // Update watch dog timer
        const landmarks = results.multiHandLandmarks[0];
        
        // --- CLAP DETECTION (Interaction between 2 hands) ---
        let isClapping = false;
        if (results.multiHandLandmarks.length === 2) {
            const hand1 = results.multiHandLandmarks[0];
            const hand2 = results.multiHandLandmarks[1];
            
            // Calculate distance between mid-palms (index 9)
            const p1 = hand1[9];
            const p2 = hand2[9];
            const dist = Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));
            
            if (dist < 0.15) { // Threshold for clap
                isClapping = true;
                calculateShape('explosion');
                return; // Skip single hand logic if clapping
            }
        }

        // --- SINGLE HAND LOGIC ---
        
        // Rotation Mappings
        const cx = landmarks[9].x; 
        const cy = landmarks[9].y;
        targetRotation.y = (cx - 0.5) * 4; 
        targetRotation.x = (cy - 0.5) * 4;

        // Pinch Expansion
        const thumbTip = landmarks[4];
        const indexTip = landmarks[8];
        const distance = Math.sqrt(
            Math.pow(thumbTip.x - indexTip.x, 2) + 
            Math.pow(thumbTip.y - indexTip.y, 2)
        );
        
        let targetExpansion = 1.0;
        if(distance < 0.1) targetExpansion = 0.5; // Compressed
        else targetExpansion = 0.5 + (distance * 4);
        expansion += (targetExpansion - expansion) * 0.1;
        document.getElementById('expansion-val').innerText = expansion.toFixed(2);

        // --- FINGER STATE CALCULATION ---
        const wrist = landmarks[0];
        const getDist = (p1, p2) => Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));

        const isThumbUp = getDist(landmarks[4], wrist) > getDist(landmarks[3], wrist) * 1.2;
        const isIndexUp = getDist(landmarks[8], wrist) > getDist(landmarks[6], wrist) * 1.1;
        const isMiddleUp = getDist(landmarks[12], wrist) > getDist(landmarks[10], wrist) * 1.1;
        const isRingUp = getDist(landmarks[16], wrist) > getDist(landmarks[14], wrist) * 1.1;
        const isPinkyUp = getDist(landmarks[20], wrist) > getDist(landmarks[18], wrist) * 1.1;

        // Calculate standard count
        const count = (isThumbUp ? 1 : 0) + (isIndexUp ? 1 : 0) + (isMiddleUp ? 1 : 0) + (isRingUp ? 1 : 0) + (isPinkyUp ? 1 : 0);
        
        // --- GESTURE MAPPING ---
        
        // Shaka ü§ô (Thumb + Pinky only)
        if (isThumbUp && isPinkyUp && !isIndexUp && !isMiddleUp && !isRingUp) {
            calculateShape('iris');
        }
        // Rock On ü§ò (Index + Pinky only, Thumb usually tucked or crossed)
        // We ensure middle and ring are down. Thumb is flexible but strictly Rock On usually has thumb tucked.
        else if (!isThumbUp && isIndexUp && isPinkyUp && !isMiddleUp && !isRingUp) {
            calculateShape('constellation');
        }
        // Standard Counts
        else if (count === 0) {
            calculateShape('vortex');
        } else if (count === 1) {
            calculateShape('saturn');
        } else if (count === 2) {
            calculateShape('heart');
        } else if (count === 3) {
            calculateShape('flower');
        } else if (count === 4) {
            calculateShape('helix');
        } else if (count >= 5) {
             if (distance > 0.1) calculateShape('sphere');
        }
    }
}

initThree();

</script>
</body>
</html>
